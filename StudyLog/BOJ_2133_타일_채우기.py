n = int(input())

# 가로 n칸의 경우의수
# 가로 1칸 -> 0
# 가로 2칸 -> 3
# 가로 3칸 -> ?
# 애초에 가로 칸 수가 홀수면, 그 영역 안의 칸이 홀수니까 1*2 or 2*1 블럭으로 꽉 채우는건 불가능
# 가로 4칸 -> 2칸일 때 나오는 조합은 뺀다고 하면,
# 그럼 2

# 엇갈리게 놓는거는 계속해서 놓을 수 있음. 위아래 날개로 2가지 경우씩
# 그러면 현재-2 경우에서 dp[2]개 놓거나,
# 현재-4 경우에서 dp[4]개 놓거나,
# ...
# 현재-현재 경우에서 2개 놓거나

# 아니지 현재-4 경우에서 dp[4]개 놓으면 겹치는게 생길듯
# 다시 생각해보면...
# 가로 2n칸일 때,
# 2칸 이전 블록 경우의 수 * 3, 4칸 이상 이전 블록 경우의 수 각각 * 2 다 더한거


# 애초에 인풋 가로가 홀수면 그냥 0임. 걸러주자
if n%2 == 1: 
    print(0)
else:
    dp = [0 for _ in range(n//2+1)]
    dp[0] = 1 # 곱해주기 위해서 1로. 가로 0칸에 타일로 채우는 경우의 수는 안채우는거 한가지니까 의미도 ok
    dp[1] = 3
    # dp[2] = dp[1]*3 + dp[0]*2

    # 요 뒤로는 피보나치
    for i in range(2, n//2 + 1):
        dp[i] = dp[i-1]*3
        for j in range(0, i-1):
            dp[i] = dp[i] + dp[j]*2

# print(dp)
    print(dp[-1])
